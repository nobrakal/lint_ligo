\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{cite}

\author{Alexandre Moine}
\title{Activity report about the development of a linter for LIGO}
\date{September 14, 2020}

\begin{document}
\maketitle
\abstract{The Tezos Foundation has provided support for the development of a linter for LIGO during August and September 2020. This document describes the main aspects of this development.}

\section{Executive summary}

The developement led to a first publicly available version downloadable from:
\begin{center}
  \url{https://github.com/nobrakal/lint\_ligo}
\end{center}

\paragraph{Features}

\verb|lint_ligo| is a command-line tool and a library which includes the following built-in features:

\begin{itemize}
\item The detection of deprecated predefined types and values.
\item The detection of unused variables.
\item The detection of code smells.
\item In the case of a PascaLIGO file, the detection of the used dialect, and if it is mixed with the other dialect.
\end{itemize}

The linter is \textbf{extensible}. There are two ways for users to include new linting rules:

\begin{itemize}
\item Code patterns. When detected in the analyzed file, a custom message is printed to the user.
\item Custom deprecated name. When such a name is detected in the analyzed file, a custom message is printed to the user.
\end{itemize}

\paragraph{Design and implementation}

The architecture of the linter is modular: any new feature can be easily added to the linting chain as each pass is isolated from the others.\\
The tool code base is also relatively small because the source code reuses many features offered by the LIGO compiler library.

\paragraph{Community driven}
The author collaborates with the LIGO team to design the linter.\\
The original proposal mentioned the introduction of a hook for a linter in the compiler. After a proof of concept was developed, the LIGO team rejected the idea as it introduced unneeded complexity for the end-user.\\
Moreover, the idea of detecting PascaLIGO dialects came from a member of the LIGO team as a valuable addition.\\

The author also collaborates with the community to understand the kind of linting rules that are the most relevant. A member of the community suggested the idea of detecting unused variables which, after a discussion with the LIGO team, led to an integration of this feature in the linter.

\paragraph{Next steps}

\verb|lint_ligo| can be used by the LIGO community right now.
However, some work can be done to improve the usability of the tool: there is a need for a standard set of linting rules for each LIGO language and the pattern matching can be improved.
Furthermore, it could be interesting to extend the detection of unused variables to catch more cases.

\section{Details about the design and the implementation of lint-ligo}

\subsection{Structure of the project}

The client only offers a way to call the library.\\
The entry point of the library is \verb|lib/main.ml|. Its \verb|main| function will, given a rules file, a contract and an entry point for the contract:
\begin{enumerate}
\item Parse the rules file.
\item Call the compiler library to parse the contract and compile it to three different stages: the CST, the \verb|Imperative| AST and the \verb|Typed| AST.
\item Run the pattern matching and the detection of the dialect of PascaLIGO (if needed) on the CST.
\item Then run the detection of deprecated variables on the \verb|Imperative| AST.
\item Finally, run the detection of unused variables on the \verb|Typed| AST.
\end{enumerate}

Each pass is controlled by a module of the following signature:
\begin{minted}{ocaml}
  type result
  val run : ast -> result
  val format : result -> (Location.t * string) list
\end{minted}

where the formatting function allows to get a list of located warnings, which can be printed at the end to the user.

\subsection{Patterns}
Patterns are a way to capture the shape of a piece of code. They are composed of:

\begin{itemize}
\item Pattern variables (identifiers preceded by \verb|%|). Note that a "hole" variable representing an always fresh variable is available using \verb|%_|.
\item To have better control over variables, they can be typed to match only a kind of node in the AST using the syntax \verb|%x:type|. Types depend on the targetted LIGO language.
\item Meta parentheses \verb|%(| \verb|%)|: parentheses not included in the targeted code but useful to indicate the shape of the AST.
\item Any words.
\end{itemize}

More precisely, given a pattern $P$ of type $T$ and a ast $A$, the pattern matching engine will search a node $N$ of $A$ of type $T$ and a substitution $\sigma$ of the variables in $P$ such that $\sigma(P)$ is equal to $N$.

The pattern matching algorithm is based on the unparsed patterns of Rinderknecht \& Volanschi\cite{unparsedpatterns}. This induces some unusual characteristics:

\begin{itemize}
\item Patterns are \emph{not} parsed, thus they can correspond to invalid LIGO code, and no warning will be issued. Such patterns will simply not match anything.
\item Patterns are not linear, meaning that a variable can appear more than once in a pattern.
\item Variables can be typed. A typed variable will only match a node of the given type.
\end{itemize}

The main advantage of this approach is to avoid a (possibly difficult) extension of the syntaxes of LIGO to include holes and metavariables, that is a variable representing an AST.

\subsubsection{About unparsed patterns}
The main module is located in \verb|lib/run_pattern.ml| which is a functor taking an unparser (from \verb|lib/unparser/|) and producing the engine. However, most of the work does not depend on any unparser and is located in \verb|lib/pattern.ml|.\\
The linter ``unparses'' the corresponding CST to a simpler tree and then runs the pattern matching algorithm of Rinderknecht \& Volanschi \cite{unparsedpatterns}.
Note that this work needed a small modification of the ReasonLIGO CST to include more information, see \url{https://gitlab.com/ligolang/ligo/-/merge_requests/785}.

\subsubsection{Example}
The pattern detecting an useless test in CameLIGO:
\begin{minted}{ocaml}
if %_ then %x else %x
\end{minted}

will match the following expressions
\begin{minted}{ocaml}
if true then x else x

if (b || c) then (1 + 2) else (1 + 2)
\end{minted}

\subsection{PascaLIGO dialects}
The analysis is located in \verb|lib/pascaligo_flavor.ml| and made on the PascaLIGO CST. It is a fold over the CST, deducing a dialect when possible, and raising an error when two different dialects are detected.\\
An option was also added to the compiler to choose the dialect when decompiling to PascaLIGO, see \url{https://gitlab.com/ligolang/ligo/-/merge_requests/791}.

\subsection{Deperacted constants}

The analysis is located in \verb|lib/unused_variables.ml| and made by a traversal of the \verb|Imperative| AST. Indeed, all deprecated built-ins are marked as such thanks to \url{https://gitlab.com/ligolang/ligo/-/merge_requests/782}.

\subsection{Unused variables}

The analysis is located in \verb|lib/deprecate.ml| and made on the \verb|Typed| AST because the structure is much simpler to analyze than structures from earlier passes. The AST is folded to a map linking each variable to a boolean indicating if it was used in the code or not (note that efforts were made to save this information in case of a name capture).
This analysis mimics the one made the OCaml compiler: variables with a name starting by an underscore are not analyzed.\\
Moreover, it returns an under-approximation of the whole set of unused variables.
For example with the program:
\begin{minted}{ocaml}
  let x = 42 in
  let y = x  in
  ()
\end{minted}
Only the variable \verb|y| will be marked as unused because of \verb|x| being used in the definition of \verb|y|.

\bibliographystyle{plain}
\bibliography{publications}{}
\end{document}